""" Script to generate a python const file with public chain RPC endpoints from the Ethereum
Foundation ethereum-lists/chains repo.

Usage
-----
python scripts/update_rpc.py
"""
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional
from urllib.parse import urljoin

import requests
from pydantic import BaseModel

from ape.logging import logger

CHAIN_IDS = {
    "arbitrum": {
        "mainnet": 42161,
        "goerli": 421613,
        "sepolia": 421614,
    },
    "avalanche": {
        "mainnet": 43114,
        "fuji": 43113,
    },
    "base": {
        "mainnet": 8453,
        "sepolia": 84532,
    },
    "bsc": {
        "mainnet": 56,
        "testnet": 97,
    },
    "ethereum": {
        "mainnet": 1,
        "goerli": 5,
        "sepolia": 11155111,
    },
    "fantom": {
        "mainnet": 250,
        "testnet": 4002,
    },
    "gnosis": {
        "mainnet": 100,
    },
    "optimism": {
        "mainnet": 10,
        "goerli": 420,
        "sepolia": 11155420,
    },
    "polygon": {
        "mainnet": 137,
        "mumbai": 80001,
    },
    "polygon-zkevm": {
        "mainnet": 1101,
        "testnet": 1442,
    },
}
INCLUDE_PROTOCOLS = ["http", "https"]
SOURCE_URL = "https://raw.githubusercontent.com/ethereum-lists/chains/master/_data/chains/"
CHAIN_CONST_FILE = Path(__file__).parent.parent / "src" / "ape_geth" / "chains.py"
BLACKLIST_STRINGS = [
    # 2024-01-19: Node appears to be broken.  Returning errors on simple requests.
    "rpc.blocknative.com"
]


class Chain(BaseModel):
    name: str
    chain: str
    icon: Optional[str] = None
    rpc: List[str]
    features: Optional[List[Dict[str, str]]] = None
    faucets: List[str]
    nativeCurrency: Dict[str, Any]
    infoURL: str
    shortName: str
    chainId: int
    networkId: int
    slip44: Optional[int] = None
    ens: Optional[Dict[str, str]] = None
    explorers: List[Dict[str, str]]


def stamp() -> str:
    """UTC timestamp for file header"""
    return str(datetime.utcnow())


def ensure_dict(d: Dict[str, Any], key: str):
    if key in d and isinstance(d[key], dict):
        return
    d[key] = dict()


def is_uri_blacklisted(uri: str) -> bool:
    """Check if a URI is blacklisted."""
    for blacklisted in BLACKLIST_STRINGS:
        if blacklisted in uri:
            return True
    return False


def fetch_chain(chain_id: int) -> Chain:
    """Fetch a chain from the ethereum-lists repo."""
    url = urljoin(SOURCE_URL, f"eip155-{chain_id}.json")

    logger.info(f"GET {url}")
    r = requests.get(url)
    r.raise_for_status()

    chain = Chain.model_validate_json(r.text)

    # Filter out blacklised URIs
    chain.rpc = list(filter(lambda rpc: not is_uri_blacklisted(rpc), chain.rpc))

    # Filter out unwanted protocols (e.g. websocket)
    chain.rpc = list(filter(lambda rpc: rpc.split(":")[0] in INCLUDE_PROTOCOLS, chain.rpc))

    return chain


def fetch_chains() -> Dict[str, Dict[str, Chain]]:
    """Fetch all chains from the ethereum-lists repo."""
    chains: Dict[str, Dict[str, Chain]] = {}
    for ecosystem in CHAIN_IDS.keys():
        for network, chain_id in CHAIN_IDS[ecosystem].items():
            logger.info(f"Fetching chain {ecosystem}:{network} ({chain_id})")
            ensure_dict(chains, ecosystem)
            chains[ecosystem][network] = fetch_chain(chain_id)
    return chains


def write_chain_const(chains: Dict[str, Dict[str, Chain]]):
    """Write the file with Python constant"""
    with CHAIN_CONST_FILE.open("w") as const_file:
        const_file.write("# This file is auto-generated by scripts/update_rpc.py\n")
        const_file.write(f"# {stamp()}\n")
        const_file.write("# Do not edit this file directly.\n")
        const_file.write("from typing import Dict, List\n\n")
        const_file.write("PUBLIC_CHAIN_RPCS: Dict[str, Dict[str, List[str]]] = {\n")
        for ecosystem in chains.keys():
            const_file.write(f'    "{ecosystem}": {{\n')
            for network, chain in chains[ecosystem].items():
                const_file.write(f'        "{network}": [\n')
                for rpc in chain.rpc:
                    if "${" in rpc:
                        continue
                    const_file.write(f'            "{rpc}",\n')
                const_file.write("        ],\n")
            const_file.write("    },\n")
        const_file.write("}\n")


def main():
    logger.info("Fetching chain data...")
    logger.info(f"    Source: {SOURCE_URL}")
    logger.info(f"    Dest: {CHAIN_CONST_FILE}")
    chains = fetch_chains()
    write_chain_const(chains)


if __name__ == "__main__":
    main()
